# Secure Voting System

A comprehensive implementation of a secure electronic voting system using homomorphic encryption and zero-knowledge proofs.

## üöÄ Usage Examples

### Basic Usage:
```bash
# Run complete demonstration
python voting_system_demo.py

# Or import and use programmatically
from secure_voting_system import run_voting_simulation, VoteValue

votes = [
    ("Alice", VoteValue.YES),
    ("Bob", VoteValue.NO),
    ("Charlie", VoteValue.YES)
]


"""Normal election"""
results = run_voting_simulation(votes)

"""Election with fraud detection"""
results = run_voting_simulation(votes, fraudulent_voters=["Bob"])
```

### Running Tests:
```bash
python voting_system_tests.py
```

```bash
### Full Demo:
python voting_system_demo.py
```

## üéØ Overview

This system demonstrates a complete secure voting workflow that ensures:
- **Vote Privacy**: Individual votes remain encrypted and private
- **Vote Integrity**: Zero-knowledge proofs verify vote authenticity without revealing content
- **Fraud Detection**: Cryptographic verification catches tampering attempts
- **Secure Aggregation**: Final tallies computed without decrypting individual votes

## üèóÔ∏è Architecture

1. **Simulator**: Generates votes and provides cryptographic proofs
2. **Client (Kiosk)**: Handles encryption/decryption and commitment generation
3. **Server**: Aggregates encrypted votes and verifies zero-knowledge proofs

## üîí Cryptographic Components

### Homomorphic Encryption (Paillier)
- Enables computation on encrypted data
- Allows vote tallying without decryption
- Maintains individual vote privacy

### Zero-Knowledge Proofs (Sigma Protocol)
- Proves knowledge of vote without revealing it
- Based on Schnorr identification protocol
- Enables fraud detection and prevention

## üß™ Test Cases

### 1. Normal Flow Test
- Demonstrates standard voting process
- All proofs should verify successfully
- Shows homomorphic tally computation

### 2. Fraud Detection Test
- Simulates fraudulent vote submission
- Demonstrates zero-knowledge proof failure
- Shows system's ability to detect tampering

### 3. Custom Election Demo
- Board voting scenario with 5 members
- Real-world example usage

### 4. Large Election Demo
- Scales to 20 voters automatically
- Demonstrates performance with larger datasets

## üîß Configuration

The system uses `voting_config.py` for all configurable parameters:

- **Crypto Settings**: Prime ranges, key sizes, protocol parameters
- **System Settings**: Voter limits, timeouts, logging levels
- **Network Settings**: Ports and communication parameters (for future network implementation)

## üîê Security Features

### Vote Privacy
- Individual votes never stored in plaintext
- Homomorphic encryption preserves privacy during aggregation
- Only final tally is revealed

### Vote Integrity
- Zero-knowledge proofs verify each vote's authenticity
- Sigma protocol ensures voters know their secret
- Cryptographic commitments prevent vote changing

### Fraud Prevention
- Server verifies all proofs before accepting results
- Invalid proofs are detected and rejected
- System maintains audit trail of all verifications


## üî¨ Technical Details

### Paillier Cryptosystem
- **Key Generation**: Uses random primes p, q to compute n = p√óq
- **Encryption**: E(m) = g^m √ó r^n (mod n¬≤)
- **Homomorphic Property**: E(m‚ÇÅ) √ó E(m‚ÇÇ) = E(m‚ÇÅ + m‚ÇÇ)

### Sigma Protocol
- **Commitment**: a = g^r (mod p)
- **Challenge**: c ‚àà·¥ø Z‚Çö
- **Response**: z = r + c√ów
- **Verification**: g^z ‚âü a √ó k^c (mod p)

## üöß Limitations & Future Work

### Current Limitations
- Simulated network communication


## üìö References
- [Paillier Cryptosystem](https://github.com/0riv3r/confidential_computing_class/blob/main/notebooks/he_paillier_python.ipynb)
- [Sigma (Schnorr) Identification Protocol](https://github.com/0riv3r/confidential_computing_class/blob/main/notebooks/zkp-sigma.ipynb)
