# Secure Voting System

A comprehensive implementation of a secure electronic voting system using homomorphic encryption and zero-knowledge proofs.

## ğŸš€ Usage Examples

### Basic Usage:
from secure_voting_system import run_voting_simulation, VoteValue

votes = [
    ("Alice", VoteValue.YES),
    ("Bob", VoteValue.NO),
    ("Charlie", VoteValue.YES)
]

"""Normal election"""
results = run_voting_simulation(votes)

"""Election with fraud detection"""
results = run_voting_simulation(votes, fraud_voter_id="Bob")

### Running Tests:
python voting_system_tests.py

### Full Demo:
python voting_system_demo.py

## ğŸ¯ Overview

This system demonstrates a complete secure voting workflow that ensures:
- **Vote Privacy**: Individual votes remain encrypted and private
- **Vote Integrity**: Zero-knowledge proofs verify vote authenticity without revealing content
- **Fraud Detection**: Cryptographic verification catches tampering attempts
- **Secure Aggregation**: Final tallies computed without decrypting individual votes

## ğŸ—ï¸ Architecture

1. **Simulator**: Generates votes and provides cryptographic proofs
2. **Client (Kiosk)**: Handles encryption/decryption and commitment generation
3. **Server**: Aggregates encrypted votes and verifies zero-knowledge proofs

## ğŸ”’ Cryptographic Components

### Homomorphic Encryption (Paillier)
- Enables computation on encrypted data
- Allows vote tallying without decryption
- Maintains individual vote privacy

### Zero-Knowledge Proofs (Sigma Protocol)
- Proves knowledge of vote without revealing it
- Based on Schnorr identification protocol
- Enables fraud detection and prevention

## ğŸ“ File Structure

```
secure_voting_system/
â”œâ”€â”€ crypto_wrapper_enhanced.py    # Enhanced cryptographic primitives
â”œâ”€â”€ secure_voting_system.py       # Main system implementation
â”œâ”€â”€ voting_system_demo.py         # Demo runner and test cases
â”œâ”€â”€ voting_config.py              # Configuration management
â””â”€â”€ README.md                     # This file
```

## ğŸš€ Quick Start

### Prerequisites
- Python 3.8+
- No external dependencies (uses only standard library)

### Running the Demo

```bash
# Run complete demonstration
python voting_system_demo.py

# Or import and use programmatically
from secure_voting_system import run_voting_simulation, VoteValue

votes = [
    ("Alice", VoteValue.YES),
    ("Bob", VoteValue.NO),
    ("Charlie", VoteValue.YES)
]

results = run_voting_simulation(votes)
```

## ğŸ§ª Test Cases

### 1. Normal Flow Test
- Demonstrates standard voting process
- All proofs should verify successfully
- Shows homomorphic tally computation

### 2. Fraud Detection Test
- Simulates fraudulent vote submission
- Demonstrates zero-knowledge proof failure
- Shows system's ability to detect tampering

### 3. Custom Election Demo
- Board voting scenario with 5 members
- Real-world example usage

### 4. Large Election Demo
- Scales to 20 voters automatically
- Demonstrates performance with larger datasets

## ğŸ”§ Configuration

The system uses `voting_config.py` for all configurable parameters:

- **Crypto Settings**: Prime ranges, key sizes, protocol parameters
- **System Settings**: Voter limits, timeouts, logging levels
- **Network Settings**: Ports and communication parameters (for future network implementation)

## ğŸ” Security Features

### Vote Privacy
- Individual votes never stored in plaintext
- Homomorphic encryption preserves privacy during aggregation
- Only final tally is revealed

### Vote Integrity
- Zero-knowledge proofs verify each vote's authenticity
- Sigma protocol ensures voters know their secret
- Cryptographic commitments prevent vote changing

### Fraud Prevention
- Server verifies all proofs before accepting results
- Invalid proofs are detected and rejected
- System maintains audit trail of all verifications


## ğŸ”¬ Technical Details

### Paillier Cryptosystem
- **Key Generation**: Uses random primes p, q to compute n = pÃ—q
- **Encryption**: E(m) = g^m Ã— r^n (mod nÂ²)
- **Homomorphic Property**: E(mâ‚) Ã— E(mâ‚‚) = E(mâ‚ + mâ‚‚)

### Sigma Protocol
- **Commitment**: a = g^r (mod p)
- **Challenge**: c âˆˆá´¿ Zâ‚š
- **Response**: z = r + cÃ—w
- **Verification**: g^z â‰Ÿ a Ã— k^c (mod p)

## ğŸš§ Limitations & Future Work

### Current Limitations
- Simulated network communication


## ğŸ“š References
- [Paillier Cryptosystem](https://github.com/0riv3r/confidential_computing_class/blob/main/notebooks/he_paillier_python.ipynb)
- [Sigma (Schnorr) Identification Protocol](https://github.com/0riv3r/confidential_computing_class/blob/main/notebooks/zkp-sigma.ipynb)
